use rust_decimal::Decimal;
use derive_more::Constructor;
use serde::{Deserialize, Serialize};
use prettytable::{Table, Row, Cell};

/// Quote prices generated by [`InventorySkewQuoter`].
#[derive(Debug, Clone, Copy, PartialEq, Deserialize, Serialize, Constructor)]
pub struct Quote {
    /// Bid price to place on the exchange.
    pub bid_price: Decimal,
    /// Ask price to place on the exchange.
    pub ask_price: Decimal,
}

/// Two-sided quoting algorithm that skews prices based on inventory levels.
#[derive(Debug, Clone, Copy, PartialEq, Deserialize, Serialize, Constructor)]
pub struct InventorySkewQuoter {
    /// Desired quote spread as an absolute price difference.
    pub target_spread: Decimal,
    /// Amount to skew quotes per unit of inventory ratio.
    pub inventory_skew_factor: Decimal,
}

impl InventorySkewQuoter {
    /// Generate bid and ask prices given a mid price and current inventory ratio.
    ///
    /// `inventory_ratio` should be `current_inventory / max_inventory` where
    /// positive values indicate long inventory and negative values indicate short.
    pub fn quote(&self, mid_price: Decimal, inventory_ratio: Decimal) -> Quote {
        let half_spread = self.target_spread / Decimal::from(2);
        let skew = self.inventory_skew_factor * inventory_ratio;
        let bid = mid_price - half_spread - skew;
        let ask = mid_price + half_spread - skew;
        Quote::new(bid, ask)
    }
}

/// Optimize a spread based on market volatility with an upper bound.
pub fn optimize_spread(base_spread: Decimal, volatility: Decimal, max_spread: Decimal) -> Decimal {
    let proposed = base_spread * (Decimal::ONE + volatility);
    if proposed > max_spread { max_spread } else { proposed }
}

/// Simple inventory risk controls.
#[derive(Debug, Clone, Copy, PartialEq, Deserialize, Serialize, Constructor)]
pub struct RiskControls {
    /// Maximum allowed inventory ratio before trading is disabled.
    pub max_inventory_ratio: Decimal,
}

impl RiskControls {
    /// Returns `true` if trading is allowed given the provided `inventory_ratio`.
    pub fn check_inventory(&self, inventory_ratio: Decimal) -> bool {
        inventory_ratio.abs() <= self.max_inventory_ratio
    }
}

/// Track basic performance metrics like realised PnL.
#[derive(Debug, Default, Clone, PartialEq, Deserialize, Serialize)]
pub struct PerformanceTracker {
    realised_pnl: Decimal,
    trades: usize,
}

impl PerformanceTracker {
    /// Record PnL for a completed trade.
    pub fn record_trade(&mut self, pnl: Decimal) {
        self.realised_pnl += pnl;
        self.trades += 1;
    }

    /// Realised profit and loss.
    pub fn realised_pnl(&self) -> Decimal {
        self.realised_pnl
    }

    /// Number of trades executed.
    pub fn trades(&self) -> usize {
        self.trades
    }
}

/// Visualise current quotes in a table for debug purposes.
pub fn print_quotes(quote: Quote) {
    let mut table = Table::new();
    table.set_format(*prettytable::format::consts::FORMAT_CLEAN);
    table.add_row(Row::new(vec![Cell::new("Bid"), Cell::new(&quote.bid_price.to_string())]));
    table.add_row(Row::new(vec![Cell::new("Ask"), Cell::new(&quote.ask_price.to_string())]));
    table.printstd();
}

#[cfg(test)]
mod tests {
    use super::*;
    use rust_decimal_macros::dec;

    #[test]
    fn test_inventory_skew() {
        let quoter = InventorySkewQuoter::new(dec!(10), dec!(1));
        let quote = quoter.quote(dec!(100), dec!(0.5));
        assert_eq!(quote.bid_price, dec!(100) - dec!(5) - dec!(0.5));
        assert_eq!(quote.ask_price, dec!(100) + dec!(5) - dec!(0.5));
    }

    #[test]
    fn test_risk_controls() {
        let risk = RiskControls::new(dec!(0.2));
        assert!(risk.check_inventory(dec!(0.1)));
        assert!(!risk.check_inventory(dec!(0.3)));
    }

    #[test]
    fn test_spread_optimization_cap() {
        let s = optimize_spread(dec!(2), dec!(0.5), dec!(3));
        assert_eq!(s, dec!(3));
        let s = optimize_spread(dec!(2), dec!(0.1), dec!(3));
        assert_eq!(s, dec!(2.2));
    }

    #[test]
    fn test_performance_tracker() {
        let mut perf = PerformanceTracker::default();
        perf.record_trade(dec!(1));
        perf.record_trade(dec!(-0.5));
        assert_eq!(perf.trades(), 2);
        assert_eq!(perf.realised_pnl(), dec!(0.5));
    }
}
